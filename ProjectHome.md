# 基于VSM模型的中文信息检索系统 #
# 开发者：孙大鹏、刘荣橙、李健、张丽云、黄煜纯. #
# 1.项目简介 #
<p>近几年，互联网信息量呈现指数级增长，但是这并不意味着，人们可以在海量的信息中找到有价值的信息，信息检索系统就是通过对文本进行建模，帮助人们快速准确地找到有用的信息。</p>
<p>本项目致力于文本的搜索，从文本出发对文档进行建模，将用户查询看作文档，通过文档的相似度，对文档集进行打分、排序，返回最相近的文档。</p>
# 2.开发环境 #
<p>开发环境是ubuntu 11.10 下 jdk 1.6，开发工具使用的是myeclipse 8.5，web端使用的Struts+Spring的框架，项目依赖通过Maven管理，使用的均是开源组件。</p>

# 3.系统设计及原理 #
<p>基于VSM模型的中文信息检索系统，主要有三大功能模块：分词索引模块、核心搜索模块、查询反馈模块。</p>
## 3.1 分词索引模块 ##
  * 将原文档传给分词模块
  1. 将文档分成一个一个单独的单词。
  1. 去除标点符号。
  1. 去除停词(Stop word)。

<p>所谓停词(Stop word)就是一种语言中最普通的一些词，由于没有特别的意义，因而大多数情况下不能成为搜索的关键词，因而创建索引时，这种词会被去掉而减少索引的大小。</p>
<p>如：“的”,“一”，“这”，“是”等。</p>
  * 经过分词组件后得到的结果称为词元(Token)。<p>比如“我来自吉林长春。”和“吉林省的省会是长春”，处理后便得到以下词元(Token)：</p>
<p>“我”，“来自”，“吉林”，“长春”</p>
<p>“吉林省”，“省会”， “长春”</p>
<p>利用得到的词(Term)创建一个字典。将文档分词结果保存，用于以后的计算，同时，用词索引文档，合并相同的词(Term)成为文档倒排(Posting List)链表。</p>
  * 我们使用庖丁分词，建立了自己的倒排索引。
## 3.2 核心搜索模块 ##
### 3.2.1 计算权重 ###
<p>并对分词结果进行统计后，下一步要计算了TF值和IDF值。</p>
<p>影响一个词(Term)在一篇文档中的重要性主要有两个因素：</p>
  * Term Frequency (tf)：即此Term 在此文档中出现了多少次。tf 越大说明越重要。
  * Document Frequency (df)：即有多少文档包含次Term。df 越大说明越不重要。
<p>词(Term)在文档中出现的次数越多，说明此词(Term)对该文档越重要，如“吉林”这个词，在本文档中出现的次数很多，说明本文档主要就是讲这方面的事的。然而在一篇英语文档中，this 出现的次数更多，就说明越重要吗？不是的，这是由第二个因素进行调整，<br>
第二个因素说明，有越多的文档包含此词(Term), 说明此词(Term)太普通，不足以区分这些文档，因而重要性越低。</p>
### 3.2.2 向量空间模型的算法 ###
<p>我们把文档看作一系列词(Term)，每一个词(Term)都有一个权重(Term weight)，不同的词(Term)<br>
根据自己在文档中的权重来影响文档相关性的打分计算。</p>
<p>于是我们把所有此文档中词(term)的权重(term weight) 看作一个向量。<br>
Document = {term1, term2, …… ,term N}<br>
Document Vector = {weight1, weight2, …… ,weight N}<br>
同样我们把查询语句看作一个简单的文档，也用向量来表示。<br>
Query = {term1, term 2, …… , term N}<br>
Query Vector = {weight1, weight2, …… , weight N}<br>
我们把所有搜索出的文档向量及查询向量放到一个 N 维空间中，每个词(term)是一维。</li></ul>

</p>
<p>我们认为两个向量之间的夹角越小，相关性越大。<br>
所以我们计算夹角的余弦值作为相关性的打分，夹角越小，余弦值越大，打分越高，相关性越大。<br>
查询语句一般是很短的，包含的词(Term)是很少的，因而查询向量的维数很小，而文档很长，包含词(Term)很多，文档向量维数很大。要放到相同的向量空间，维数要是相同的，不同时，取二者的并集，如果不含某个词(Term)时，则权重(Term Weight)为 0。<br>
<blockquote></p><p>
我们使用问题集进行测试，结果非常好,30个样本集只有4个答案不在首位，在第二位，其余均在首位。</p>
<h2>3.3 查询反馈模块 ##
我们使用了标准Rocchio公式，简单地说，就是新的查询向量为原有查询向量，加上相关文档的平均向量，减去不相关文档的平均向量。使用新的向量进行查询。

# 4.项目测试 #
## 4.1检索系统测评理论 ##
<p>MRR（Mean reciprocal rank）是一个国际上通用的对搜索算法进行评价的机制，即第一个结果匹配，分数为1，第二个匹配分数为0.5，第n个匹配分数为1/n，如果没有匹配的句子分数为0。最终的分数为所有得分之和。<br>
简单地说，就是计算第一个正确答案出现位置的倒数平均值。</p>


## 4.2测试结果 ##
<p>应用MRR (Mean Reciprocal Rank)方法对结果进行分析：</p>
<p>Rank1=1		Rank2=1		Rank3=1		Rank4=1		Rank5=1		Rank6=1		Rank7=1<br>
Rank8=1		Rank9=1		Rank10=1		Rank11=1		Rank12=1		Rank13=1		Rank14=1<br>
Rank15=1		Rank16=1		Rank17=1		Rank18=1		Rank19=1		Rank20=1		Rank21=1<br>
Rank22=2		Rank23=1		Rank24=1		Rank25=1		Rank26=1		Rank27=2		Rank28=2<br>
Rank29=2		Rank30=1		Rank31=1		Rank32=1		Rank33=1		Rank34=1		Rank35=1<br>
Rank36=1<br>
</p>
<p>MRR = 1/36<code>*</code>(32 <code>*</code> 1/1 + 4 <code>*</code> 1/2)<br>
= 1/36<code>*</code>(34)<br>
= 0.944444<br>
</p><p>一般来说。MRR超过90%的系统就有实用的价值，通过我们的优化，达到了94%，效果非常好。</p>